
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nchapman/myrient-dl/cmd/root.go (0.0%)</option>
				
				<option value="file1">github.com/nchapman/myrient-dl/internal/downloader/downloader.go (48.7%)</option>
				
				<option value="file2">github.com/nchapman/myrient-dl/internal/matcher/matcher.go (94.1%)</option>
				
				<option value="file3">github.com/nchapman/myrient-dl/internal/parser/parser.go (84.8%)</option>
				
				<option value="file4">github.com/nchapman/myrient-dl/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "net/url"
        "os"
        "path"
        "strings"

        "github.com/nchapman/myrient-dl/internal/downloader"
        "github.com/nchapman/myrient-dl/internal/matcher"
        "github.com/nchapman/myrient-dl/internal/parser"
        "github.com/spf13/cobra"
)

var (
        outputDir    string
        includePattern string
        excludePattern string
        parallel     int
        dryRun       bool
        verbose      bool
        retryAttempts int
)

var rootCmd = &amp;cobra.Command{
        Use:   "myrient-dl [URL]",
        Short: "Download files from Myrient directory listings",
        Long: `A fast and friendly CLI tool to download files from Myrient.

Downloads files from Myrient directory listings with support for include/exclude patterns,
parallel downloads, and beautiful progress tracking.`,
        Args: cobra.ExactArgs(1),
        RunE: run,
}

func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        rootCmd.Flags().StringVarP(&amp;outputDir, "output", "o", "", "Output directory (defaults to last path component of URL)")
        rootCmd.Flags().StringVarP(&amp;includePattern, "include", "i", "*", "Include pattern (glob syntax)")
        rootCmd.Flags().StringVarP(&amp;excludePattern, "exclude", "e", "", "Exclude pattern (glob syntax)")
        rootCmd.Flags().IntVarP(&amp;parallel, "parallel", "p", 1, "Number of parallel downloads")
        rootCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be downloaded without downloading")
        rootCmd.Flags().BoolVarP(&amp;verbose, "verbose", "v", false, "Verbose output")
        rootCmd.Flags().IntVarP(&amp;retryAttempts, "retry", "r", 3, "Number of retry attempts for failed downloads")
}</span>

func run(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        targetURL := args[0]

        // Validate URL
        parsedURL, err := url.Parse(targetURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid URL: %w", err)
        }</span>

        // Determine output directory if not specified
        <span class="cov0" title="0">if outputDir == "" </span><span class="cov0" title="0">{
                outputDir = getDefaultOutputDir(parsedURL)
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Target URL: %s\n", targetURL)
                fmt.Printf("Output directory: %s\n", outputDir)
                fmt.Printf("Include pattern: %s\n", includePattern)
                if excludePattern != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Exclude pattern: %s\n", excludePattern)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Parallel downloads: %d\n", parallel)
                fmt.Println()</span>
        }

        // Parse directory listing
        <span class="cov0" title="0">fmt.Println("Fetching directory listing...")
        files, err := parser.ParseDirectoryListing(targetURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse directory listing: %w", err)
        }</span>

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no files found in directory listing")
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Found %d files\n", len(files))
        }</span>

        // Filter files based on patterns
        <span class="cov0" title="0">m := matcher.New(includePattern, excludePattern)
        filtered := m.Filter(files)

        if len(filtered) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No files match the specified patterns")
                return nil
        }</span>

        // Calculate total size
        <span class="cov0" title="0">var totalSize int64
        for _, f := range filtered </span><span class="cov0" title="0">{
                totalSize += f.Size
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nMatched %d files (total size: %s)\n", len(filtered), formatBytes(totalSize))

        if dryRun </span><span class="cov0" title="0">{
                fmt.Println("\nFiles to download (dry-run mode):")
                for _, f := range filtered </span><span class="cov0" title="0">{
                        fmt.Printf("  - %s (%s)\n", f.Name, formatBytes(f.Size))
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Create output directory
        <span class="cov0" title="0">if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        // Download files
        <span class="cov0" title="0">fmt.Println("\nStarting downloads...")
        dl := downloader.New(downloader.Config{
                OutputDir:     outputDir,
                Parallel:      parallel,
                RetryAttempts: retryAttempts,
                Verbose:       verbose,
        })

        if err := dl.DownloadAll(filtered); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("download failed: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("\n✓ All downloads completed!")
        return nil</span>
}

// getDefaultOutputDir extracts the last meaningful path component from the URL
func getDefaultOutputDir(u *url.URL) string <span class="cov0" title="0">{
        // Clean the path and remove trailing slashes
        cleanPath := strings.TrimSuffix(u.Path, "/")

        // Get the last component
        lastComponent := path.Base(cleanPath)

        // Decode URL encoding (e.g., %20 -&gt; space)
        decoded, err := url.QueryUnescape(lastComponent)
        if err != nil </span><span class="cov0" title="0">{
                decoded = lastComponent
        }</span>

        // Sanitize for filesystem
        <span class="cov0" title="0">sanitized := sanitizeFilename(decoded)

        // Fallback if we got nothing useful
        if sanitized == "" || sanitized == "." || sanitized == "/" </span><span class="cov0" title="0">{
                return "myrient-downloads"
        }</span>

        <span class="cov0" title="0">return "./" + sanitized</span>
}

// sanitizeFilename removes or replaces characters that are problematic for filenames
func sanitizeFilename(name string) string <span class="cov0" title="0">{
        // Replace problematic characters with underscores
        replacer := strings.NewReplacer(
                ":", "_",
                "|", "_",
                "&lt;", "_",
                "&gt;", "_",
                "\"", "_",
                "?", "_",
                "*", "_",
        )
        return replacer.Replace(name)
}</span>

// formatBytes formats byte sizes in human-readable format
func formatBytes(bytes int64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f %ciB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package downloader

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/nchapman/myrient-dl/internal/parser"
        "github.com/schollz/progressbar/v3"
)

// Config holds the downloader configuration
type Config struct {
        OutputDir     string
        Parallel      int
        RetryAttempts int
        Verbose       bool
}

// Downloader manages file downloads
type Downloader struct {
        config Config
        client *http.Client
}

// New creates a new Downloader with the given config
func New(config Config) *Downloader <span class="cov10" title="7">{
        return &amp;Downloader{
                config: config,
                client: &amp;http.Client{
                        Timeout: 30 * time.Minute, // Long timeout for large files
                },
        }
}</span>

// DownloadAll downloads all files with progress tracking
func (d *Downloader) DownloadAll(files []parser.FileInfo) error <span class="cov1" title="1">{
        total := len(files)

        if d.config.Parallel == 1 </span><span class="cov1" title="1">{
                // Serial downloads with detailed progress
                for i, file := range files </span><span class="cov4" title="2">{
                        fmt.Printf("\n[%d/%d] Downloading: %s\n", i+1, total, file.Name)

                        if err := d.downloadFileWithRetry(file); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to download %s: %w", file.Name, err)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Parallel downloads
                return d.downloadParallel(files)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// downloadFileWithRetry downloads a single file with retry logic
func (d *Downloader) downloadFileWithRetry(file parser.FileInfo) error <span class="cov4" title="2">{
        var lastErr error

        for attempt := 1; attempt &lt;= d.config.RetryAttempts; attempt++ </span><span class="cov4" title="2">{
                err := d.downloadFile(file)
                if err == nil </span><span class="cov4" title="2">{
                        return nil
                }</span>

                <span class="cov0" title="0">lastErr = err
                if attempt &lt; d.config.RetryAttempts </span><span class="cov0" title="0">{
                        fmt.Printf("  ⚠ Attempt %d failed, retrying...\n", attempt)
                        time.Sleep(time.Second * time.Duration(attempt)) // Exponential backoff
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("failed after %d attempts: %w", d.config.RetryAttempts, lastErr)</span>
}

// downloadFile downloads a single file with progress bar
func (d *Downloader) downloadFile(file parser.FileInfo) error <span class="cov8" title="5">{
        outputPath := filepath.Join(d.config.OutputDir, file.Name)

        // Get the actual file size from the server
        actualSize, err := d.getRemoteFileSize(file.URL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get file size: %w", err)
        }</span>

        // Check if file already exists with the correct size
        <span class="cov8" title="5">if info, err := os.Stat(outputPath); err == nil </span><span class="cov4" title="2">{
                if info.Size() == actualSize </span><span class="cov1" title="1">{
                        fmt.Printf("  ✓ Already downloaded (skipping)\n")
                        return nil
                }</span>
                <span class="cov1" title="1">if d.config.Verbose </span><span class="cov0" title="0">{
                        fmt.Printf("  ⚠ File exists but size mismatch (local: %d, remote: %d), re-downloading\n",
                                info.Size(), actualSize)
                }</span>
        }

        // Create the request
        <span class="cov7" title="4">resp, err := d.client.Get(file.URL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="4">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("server returned status %d", resp.StatusCode)
        }</span>

        // Create the output file
        <span class="cov7" title="4">out, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="4">defer out.Close()

        // Create progress bar
        bar := progressbar.DefaultBytes(
                resp.ContentLength,
                "  downloading",
        )

        // Copy with progress tracking
        _, err = io.Copy(io.MultiWriter(out, bar), resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">fmt.Println() // New line after progress bar
        return nil</span>
}

// getRemoteFileSize makes a HEAD request to get the actual file size from the server
func (d *Downloader) getRemoteFileSize(url string) (int64, error) <span class="cov10" title="7">{
        resp, err := d.client.Head(url)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="7">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("server returned status %d", resp.StatusCode)
        }</span>

        <span class="cov9" title="6">return resp.ContentLength, nil</span>
}

// downloadParallel downloads files in parallel
func (d *Downloader) downloadParallel(files []parser.FileInfo) error <span class="cov0" title="0">{
        var (
                wg     sync.WaitGroup
                errCh  = make(chan error, len(files))
                semaphore = make(chan struct{}, d.config.Parallel)
        )

        total := len(files)
        completed := 0
        var mu sync.Mutex

        for _, file := range files </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(f parser.FileInfo) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Acquire semaphore
                        semaphore &lt;- struct{}{}
                        defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>()

                        <span class="cov0" title="0">mu.Lock()
                        current := completed + 1
                        mu.Unlock()

                        fmt.Printf("\n[%d/%d] Downloading: %s\n", current, total, f.Name)

                        if err := d.downloadFileWithRetry(f); err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- fmt.Errorf("failed to download %s: %w", f.Name, err)
                                return
                        }</span>

                        <span class="cov0" title="0">mu.Lock()
                        completed++
                        mu.Unlock()</span>
                }(file)
        }

        // Wait for all downloads to complete
        <span class="cov0" title="0">wg.Wait()
        close(errCh)

        // Check for errors
        if len(errCh) &gt; 0 </span><span class="cov0" title="0">{
                return &lt;-errCh
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package matcher

import (
        "path/filepath"

        "github.com/nchapman/myrient-dl/internal/parser"
)

// Matcher handles include/exclude pattern matching
type Matcher struct {
        includePattern string
        excludePattern string
}

// New creates a new Matcher with the given patterns
func New(include, exclude string) *Matcher <span class="cov6" title="9">{
        return &amp;Matcher{
                includePattern: include,
                excludePattern: exclude,
        }
}</span>

// Filter applies include/exclude patterns to a list of files
func (m *Matcher) Filter(files []parser.FileInfo) []parser.FileInfo <span class="cov6" title="9">{
        var filtered []parser.FileInfo

        for _, file := range files </span><span class="cov10" title="43">{
                if m.matches(file.Name) </span><span class="cov8" title="21">{
                        filtered = append(filtered, file)
                }</span>
        }

        <span class="cov6" title="9">return filtered</span>
}

// matches checks if a filename matches the include/exclude criteria
func (m *Matcher) matches(filename string) bool <span class="cov10" title="43">{
        // Check include pattern
        if m.includePattern != "" &amp;&amp; m.includePattern != "*" </span><span class="cov9" title="31">{
                matched, err := filepath.Match(m.includePattern, filename)
                if err != nil || !matched </span><span class="cov8" title="19">{
                        return false
                }</span>
        }

        // Check exclude pattern
        <span class="cov8" title="24">if m.excludePattern != "" </span><span class="cov6" title="12">{
                matched, err := filepath.Match(m.excludePattern, filename)
                if err != nil </span><span class="cov0" title="0">{
                        return true // If pattern is invalid, don't exclude
                }</span>
                <span class="cov6" title="12">if matched </span><span class="cov3" title="3">{
                        return false
                }</span>
        }

        <span class="cov8" title="21">return true</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package parser

import (
        "fmt"
        "io"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"

        "github.com/PuerkitoBio/goquery"
)

// FileInfo represents a file in the directory listing
type FileInfo struct {
        Name string
        URL  string
        Size int64
}

// ParseDirectoryListing fetches and parses an Apache-style directory listing
func ParseDirectoryListing(directoryURL string) ([]FileInfo, error) <span class="cov4" title="3">{
        // Fetch the directory listing
        resp, err := http.Get(directoryURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch directory: %w", err)
        }</span>
        <span class="cov4" title="3">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("server returned status %d", resp.StatusCode)
        }</span>

        <span class="cov3" title="2">return parseHTML(resp.Body, directoryURL)</span>
}

// parseHTML extracts file information from the HTML directory listing
func parseHTML(r io.Reader, baseURL string) ([]FileInfo, error) <span class="cov3" title="2">{
        doc, err := goquery.NewDocumentFromReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse HTML: %w", err)
        }</span>

        <span class="cov3" title="2">var files []FileInfo

        // Apache directory listings use &lt;a&gt; tags for file links
        // We look for links that are NOT the parent directory (..)
        doc.Find("a").Each(func(i int, s *goquery.Selection) </span><span class="cov8" title="10">{
                href, exists := s.Attr("href")
                if !exists </span><span class="cov0" title="0">{
                        return
                }</span>

                // Skip parent directory links
                <span class="cov8" title="10">if href == "../" || href == ".." </span><span class="cov3" title="2">{
                        return
                }</span>

                // Skip query parameters (sorting links)
                <span class="cov7" title="8">if strings.Contains(href, "?C=") </span><span class="cov4" title="3">{
                        return
                }</span>

                // Skip directories (end with /)
                <span class="cov6" title="5">if strings.HasSuffix(href, "/") </span><span class="cov1" title="1">{
                        return
                }</span>

                // Get the filename (text content of the link)
                <span class="cov5" title="4">name := strings.TrimSpace(s.Text())
                if name == "" </span><span class="cov0" title="0">{
                        name = href
                }</span>

                // Build absolute URL
                <span class="cov5" title="4">fileURL, err := buildAbsoluteURL(baseURL, href)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                // Try to extract size from the HTML
                // Apache listings typically show size in the same row
                <span class="cov5" title="4">size := extractSize(s)

                files = append(files, FileInfo{
                        Name: name,
                        URL:  fileURL,
                        Size: size,
                })</span>
        })

        <span class="cov3" title="2">return files, nil</span>
}

// buildAbsoluteURL constructs an absolute URL from a base and relative path
func buildAbsoluteURL(base, relative string) (string, error) <span class="cov8" title="9">{
        baseURL, err := url.Parse(base)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        <span class="cov7" title="8">relURL, err := url.Parse(relative)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov7" title="8">return baseURL.ResolveReference(relURL).String(), nil</span>
}

// extractSize attempts to extract file size from the HTML context
// Apache directory listings show size like "70.5 KiB" or "1.2 MiB"
func extractSize(s *goquery.Selection) int64 <span class="cov5" title="4">{
        // Try multiple strategies to find the size

        // Strategy 1: Look in parent table cell (td)
        td := s.Parent()
        if td.Is("td") </span><span class="cov5" title="4">{
                // Look at the next sibling(s) for size
                nextTd := td.Next()
                if nextTd.Length() &gt; 0 </span><span class="cov5" title="4">{
                        text := nextTd.Text()
                        if size := parseSizeString(text); size &gt; 0 </span><span class="cov0" title="0">{
                                return size
                        }</span>
                }
        }

        // Strategy 2: Look at the parent row (tr) or container
        <span class="cov5" title="4">row := s.Closest("tr")
        if row.Length() &gt; 0 </span><span class="cov5" title="4">{
                text := row.Text()
                if size := parseSizeString(text); size &gt; 0 </span><span class="cov5" title="4">{
                        return size
                }</span>
        }

        // Strategy 3: Look at parent element's text (for non-table layouts)
        <span class="cov0" title="0">text := s.Parent().Text()
        return parseSizeString(text)</span>
}

// parseSizeString extracts size from a string like "70.5 KiB"
func parseSizeString(text string) int64 <span class="cov10" title="16">{
        // Try to find size patterns like "70.5 KiB", "1.2 MiB", "500 B"
        sizeRegex := regexp.MustCompile(`(\d+(?:\.\d+)?)\s*(B|KiB|MiB|GiB|TiB|K|M|G|T)(?:\s|$)`)
        matches := sizeRegex.FindStringSubmatch(text)

        if len(matches) &lt; 3 </span><span class="cov7" title="7">{
                return 0
        }</span>

        <span class="cov8" title="9">value, err := strconv.ParseFloat(matches[1], 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="9">unit := matches[2]

        // Convert to bytes
        multiplier := int64(1)
        switch unit </span>{
        case "K", "KiB":<span class="cov3" title="2">
                multiplier = 1024</span>
        case "M", "MiB":<span class="cov3" title="2">
                multiplier = 1024 * 1024</span>
        case "G", "GiB":<span class="cov3" title="2">
                multiplier = 1024 * 1024 * 1024</span>
        case "T", "TiB":<span class="cov1" title="1">
                multiplier = 1024 * 1024 * 1024 * 1024</span>
        }

        <span class="cov8" title="9">return int64(value * float64(multiplier))</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import "github.com/nchapman/myrient-dl/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
